CODE REVIEW AND REFACTORING NOTES
==================================
----------------------------------------------------------------

ISSUE 1: Type & data-model issues

Type & data-model issues
Original code:
interface WalletBalance {
  currency: string;
  amount: number;
}
But later you use:
getPriority(balance.blockchain);

`blockchain` is not part of WalletBalance. This will either be a TypeScript error (if strict enough).

Fix: Extend the interface to match actual usage.
Fixed Code:
type Blockchain = "Osmosis" | "Ethereum" | "Arbitrum" | "Zilliqa" | "Neo";

interface WalletBalance {
  currency: string;
  amount: number;
  blockchain: Blockchain;
}

----------------------------------------------------------------

ISSUE 2: FormattedWalletBalance doesn’t match actual values

Original code:
interface FormattedWalletBalance {
  currency: string;
  amount: number;
  formatted: string;
}

- sortedBalances is a WalletBalance[]
- formattedBalances does produce FormattedWalletBalance[]
- rows maps over sortedBalances but types the items as FormattedWalletBalance:
const rows = sortedBalances.map(
  (balance: FormattedWalletBalance, index: number) => {
    const usdValue = prices[balance.currency] * balance.amount;
    ...
  }
);
So the type says formatted exists, but sortedBalances doesn’t actually have formatted.
Use formattedBalances when need formatted, or
Have a single type and actually add formatted before using it.

----------------------------------------------------------------

ISSUE 3: Overuse of any

Original code:
const getPriority = (blockchain: any): number => { ... }

Using any defeats TypeScript’s safety and allows invalid values.

Fixed code:
const getPriority = (blockchain: Blockchain): number => { ... }

----------------------------------------------------------------

ISSUE 4: Logic Bugs - lhsPriority is not defined

Original code:
.filter((balance: WalletBalance) => {
  const balancePriority = getPriority(balance.blockchain);
  if (lhsPriority > -99) {
    if (balance.amount <= 0) {
      return true;
    }
  }
  return false;
})
- lhsPriority is not defined anywhere then runtime error.

Filter condition is likely inverted
That means:
- Include balances that do have valid priority (> -99)
- And have amount <= 0
Keeping zero or negative balances and dropping positive ones is almost always the opposite of what is desired.

Likely intended:
return balancePriority > -99 && balance.amount > 0;

Sort comparator does not always return a number

Original code:
.sort((lhs: WalletBalance, rhs: WalletBalance) => {
  const leftPriority = getPriority(lhs.blockchain);
  const rightPriority = getPriority(rhs.blockchain);
  if (leftPriority > rightPriority) {
    return -1;
  } else if (rightPriority > leftPriority) {
    return 1;
  }
});
If priorities are equal, this function returns undefined. The comparator must always return a number (negative, zero, or positive).

Fixed code:
return rightPriority - leftPriority; // descending
----------------------------------------------------------------

ISSUE 5: React & hooks anti-patterns / inefficiencies
- useMemo dependency misuse
const sortedBalances = useMemo(() => {
  ...
}, [balances, prices]);

Inside the memo callback it only use:
	- balances
	- getPriority (which is recreated on each render but doesn’t depend on props/state)
	- That do not use prices.

Adding prices to the dependency array means sortedBalances recomputes whenever prices change, even though prices aren’t used in that computation(unnecessary work).

Fix:move getPriority outside the component so it’s not re-created each render.

- Unnecessary separate maps (sortedBalances vs formattedBalances)
Original code:
const formattedBalances = sortedBalances.map((balance: WalletBalance) => {
  return {
    ...balance,
    formatted: balance.amount.toFixed(),
  };
});

const rows = sortedBalances.map(...);

~ It compute formattedBalances, but never use it for rows.
*then re-iterate over sortedBalances to build rows.
*and also incorrectly type the balances as FormattedWalletBalance.

Fix: Use a single map to enrich balances, or use formattedBalances when building rows.

- Keying list items by array index
Original code:
<WalletRow
  key={index}
  ...
/>

Using index as key is an anti-pattern when:
	~ Array order can change (that sort and filter), and
	~ Items have a stable identity (they do here: currency or blockchain).

This can cause subtle bugs with component state and inefficient re-renders.
Fix:

Use a stable unique property, e.g.:
key={balance.currency}

- React.FC and unused children
Original code:
const WalletPage: React.FC<Props> = (props: Props) => {
  const { children, ...rest } = props;
  ...
  return <div {...rest}>{rows}</div>;
};
 ~ That destructure children and then don’t use it.
 ~ Modern TS/React codebases often avoid React.FC as it can interfere with implicit children typing and has some other downsides.

Fix:
	~ Either use children in the JSX or remove it.
	~ Consider a plain function component type:
  const WalletPage = (props: Props) => { ... };

- Formatting value precision
Original code:
formatted: balance.amount.toFixed(),

toFixed() without arguments defaults to 0 decimal places → likely not ideal for monetary values.

Fix: Use appropriate precision, e.g. toFixed(2) or configurable.
----------------------------------------------------------------

ISSUE 6: Potential re-render inefficiencies
All of this happens on every render:
	- getPriority is redefined (cheap, but unnecessary)
	- sortedBalances computed with useMemo which may re-run too often due to wrong dependencies
	- rows is computed without memoization and includes multiplication for every render

Usually this is fine, but if balances is large, can optimize:
	- Move getPriority out of the component
	- Ensure dependency arrays are minimal
	- Optionally memoize rows as well

----------------------------------------------------------------


